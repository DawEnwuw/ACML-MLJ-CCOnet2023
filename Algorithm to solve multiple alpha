T = 10

L_time_2 = []
L_prediction_2 = []
L_loss_2 = []

y0 = np.ones((ny, ))
net = FNN(y0)
optimizer = Adam(net.parameters(), lr=0.0001, weight_decay=0.01)
NPE_best = 4070995.28

for alpha in np.arange(0.35, 0.40, 0.001):
    psi = norm.ppf(1-alpha)
    f, g, ODE, projection, evalutation = ODE_psi(psi)
    vODE = vmap(ODE)
    
    start = timeit.default_timer()
    for i in range(300):
        # ORR mechanism
        pred_curr = predict(net)
        NPE_curr = evalutation(pred_curr)
        if NPE_curr < NPE_best:
            NPE_best = NPE_curr
            y0 = pred_curr

        # GD training
        t = np.random.uniform(0, T, (NBATCH, 1))
        t = torch.tensor(t, dtype=torch.float, requires_grad=True)

        loss = loss_compute(t, net, vODE)
        loss.backward()
        optimizer.step()
        optimizer.zero_grad()
            
        # Monitor
        if i%10==0:
            print(f'alpha: {alpha}, Iteration: {i}, Loss: {loss.item() :.0f}, epsilon_current: {NPE_curr :.0f}, epsilon_best: {NPE_best :.2f}, y0:{y0}')
        if torch.isnan(loss):
            net = FNN(y0)
            optimizer = Adam(net.parameters(), lr=0.0001, weight_decay=0.01)
            break
        L_loss_2.append(loss.item())
    L_time_2.append(timeit.default_timer()-start)
    L_prediction_2.append(y0)
